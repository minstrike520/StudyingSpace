We don't use it anymore, computers are wicked fast.

The basis of the algorithm is to convert to convert log2(x), multiply by -1/2 (log2 x-1/2 == -1/2 log2(x)), then raise 2 to that number to get back x-1/2.

The trick is there's a hack using how numbers are represented to approximate log2(x) and 2x , so you don't actually need to use expensive operations like logarithm/exponentiation.

The final step is to recognize these are approximations so the answer is wrong, so you use it as an initial value to something called "Newton's Method" (named after Isaac Newton) which iteratively solves for an approximation of a function. Since the initial value is pretty close, you only need to do it once.

It's not commonly used anymore directly by programmers. Like I said, computers are extremely fast now. The key reason this was used was because floating point division was very expensive, nowadays it's not the cheapest operation but it's also not the bottleneck.

# 細部架構
時代背景
- 20世紀末，3D遊戲剛開始發展
- 3D空間大量運用各種複雜的運算
- 電腦的計算能力有限
3D模型渲染
- 需要把向量「標準化」
標準化向量
- 即向量「除以」自己的長度
向量長度
我們現在來細修教學細節吧！以上是隨機數章節的一部分簡報大綱，請依照以下三點來擴張：
1. 在時代背景與模型渲染之間感覺缺乏因果關係，中間感覺可以再插入一頁ppt做銜接，其標題跟內容可以為何？
2. 模型渲染缺乏敘述，可以幫我補齊嗎？
3. 往後可以增加約四五頁，幫我生成完這個「Inverse Square Root Algorithm」的主題嗎？後面就是引入該演算法並講每個細節，如位元運算、浮點數、牛頓法。

---

了解！我會依照你的要求，幫你擴充隨機數章節中「時代背景」與「模型渲染」之間的銜接頁，補齊模型渲染部分的敘述，並且設計一個約四五頁的「Inverse Square Root Algorithm」主題教學大綱，包含位元運算、浮點數與牛頓法的介紹。

---

## 1. 銜接頁建議（時代背景 → 模型渲染）

**標題建議**：  
「3D遊戲的挑戰：如何在有限資源下呈現真實畫面？」

**內容建議**：  
- 20世紀末，3D遊戲開始流行，但當時電腦計算能力有限。  
- 3D模型渲染需要大量數學運算，尤其是向量計算。  
- 如何在有限的硬體資源下，快速且準確地完成這些運算，是當時遊戲開發者面臨的重大挑戰。  
- 接下來，我們來看看3D模型渲染的基本運算之一：向量標準化。

---

## 2. 模型渲染部分補齊敘述

**標題**：3D模型渲染中的向量標準化

**內容**：  
- 3D模型由許多頂點組成，每個頂點的位置用向量表示。  
- 為了計算光線反射、陰影和表面細節，常需要計算法向量（垂直於表面的向量）。  
- 法向量必須是「單位向量」，也就是長度為1的向量，這樣才能正確反映光線方向。  
- **向量標準化**就是將一個向量除以它的長度，使其長度變成1。  
- 計算向量長度的公式是：  
  $$
  \| \mathbf{v} \| = \sqrt{v_x^2 + v_y^2 + v_z^2}
   $$ 
- 標準化後的向量為：  
$$ 
  \mathbf{v}_{norm} = \frac{\mathbf{v}}{\| \mathbf{v} \|}
 $$ 
- 這個過程在3D渲染中非常頻繁，因此需要高效的計算方法。

---

## 3. 「Inverse Square Root Algorithm」主題教學大綱（約4-5頁）

### 頁1：主題引入與動機

- **標題**：為什麼要快速計算平方根的倒數？  
- **內容**：  
  - 在3D渲染中，向量標準化需要計算向量長度的平方根。  
  - 傳統平方根計算很耗時，影響遊戲效能。  
  - 逆平方根（Inverse Square Root）是計算標準化的關鍵步驟。  
  - 介紹一個經典且高效的演算法，讓遊戲跑得更快。

---

### 頁2：浮點數與位元運算基礎

- **標題**：理解浮點數與位元運算  
- **內容**：  
  - 浮點數的結構（符號位、指數位、尾數）簡介。  
  - 位元運算的基本概念（AND、OR、XOR、位移）。  
  - 演算法利用位元層級操作來快速估算逆平方根。  
- **視覺輔助**：浮點數結構示意圖，簡單位元運算範例。

---

### 頁3：Inverse Square Root演算法核心步驟

- **標題**：演算法的神奇一行程式碼  
- **內容**：  
  - 展示經典C語言程式碼片段（例如Quake III Arena的版本）。  
  - 解釋程式碼中「魔法數字」的作用。  
  - 如何透過位元操作快速得到平方根倒數的初步估計。  
- **互動**：讓學生猜猜「魔法數字」是怎麼來的。

---

### 頁4：牛頓法迭代優化

- **標題**：用牛頓法讓結果更精確  
- **內容**：  
  - 牛頓法的基本原理（用切線逼近函數根）。  
  - 如何用牛頓法迭代改善逆平方根的估計值。  
  - 演算法中迭代步驟的數學表達式。  
- **視覺輔助**：牛頓法迭代示意圖。

---

### 頁5：總結與效能影響

- **標題**：這個演算法為遊戲帶來什麼？  
- **內容**：  
  - 大幅提升向量標準化速度，讓遊戲渲染更流暢。  
  - 展示演算法在實際遊戲中的應用案例（如Quake III）。  
  - 鼓勵學生思考：如何用數學與程式技巧解決實際問題。  

# 個人腳本
- 雖然很難，但是可以一窺資工的面貌
- 最像魔法了
- 二進位小數
	- 二進位基礎
		- 我們看，二進位可以表達一個數，整數跟小數都可以。
		- 我們還可以斷章取義，看到一個二進位數，直接把他們接在一起得一個新的數，也可以隨便切再得到好多個數。這看起來一點用都沒有？繼續看下去。
	- 小數與科學記號
		- 我們看十進位的小數。
		- 如果你今天要表達「光速＝每秒30萬公里」，你在數字會怎麼寫？是不是通常會不想寫一堆〇？
			- 問：此時會用到一個技巧叫？科學什麼？
			- 「指數」跟「尾數」
		- 因為電腦用的是二進位，所以我們要在二進位重新想這件事情。
		- 首先，二進位的話，指數就變成2的乘冪。
		- 尾數呢？這個數介於一到十之間。那麼換到二進位，就是一到二之間。
			- 我們先寫看看尾數。我們知道位數增長就是乘以二嘛，跟十進位每位乘以10一樣；那位數變小咧？
			- 問：小數點第一位為一代表多少？
				- 正解：1/2
				- 不會：問：乘的相反是什麼？除
				- 那往左是乘，往右就是除了！除以一個二，就是二分之一...以此類推
- 浮點數
	- ieee 754的單精度浮點數`float`
	- 我們就發現，如果要表達一個有小數的數，我們可以把他拆成兩個東西，指數跟尾數
	- 位元表達的**歧義性**
		- 在這裡把我們要的數稱為「真值」
		- 把指數跟尾數的「二進位」重新理解為整數，這裡稱其為「假的數字」。但假的數字有大用處！
	- 指數
		- 實際值是假的數減去127，這樣就可以表達負數次方
		- 8位
	- 尾數
		- 我們看到跟十進位不一樣，小數點前永遠是一
		- 23位
			- 歧義性：如果用整數去解讀，就是一個23位的大數字；在浮點數裡的意思就是一個1到2之間的小數
			- 我們發現如果把假的數字除以一個大數，$2^{23}$，發現他就是真數！
	- 組合
		- 我們知道，（以前的）電腦喜歡處理三十二位數數字，所以我們想要把他組合在一起儲存。
		- 把指數表達「擺右邊」...在假的數字$X$看起來，就像是把指數的假數$E$多乘23個2！

- 取log
	- log可以拆分，e+127就處理掉了！
	- 取近似，放誤差
- 整理
	- $\frac{1}{2^{23}}(M+2^{23} * E)$ -> 裡面看起來沒什麼...
	- 我們從「假數」的觀點來看，裡面就是我們小數的「假數」！





# 會使用的公式
$$
\frac{1}{\sqrt{ x }} = x^{-1/2}
$$
